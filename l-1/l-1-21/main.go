package main

import "fmt"

//Реализовать паттерн проектирования «Адаптер» на любом примере.
//Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.
//Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой,
//несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

// Logger - клиентский интерфейс
type Logger interface {
	Log(message string)
}

// OldPrinter - старая реализация принтера, который может только использовать метод Print
type OldPrinter struct{}

// Print - метод старого принтера, который умеет печатать строки через Printf
func (_ OldPrinter) Print(str string) {
	fmt.Printf("OLD: %s\n", str)
}

// AdapterPrinter - адаптер, который хранит в себе экземпляр старого принтера
type AdapterPrinter struct {
	printer *OldPrinter
}

// Log - реализация требуемого интерфейсом метода, посредством вызова метода старого принтера
func (a AdapterPrinter) Log(message string) {
	a.printer.Print(message)
}

// ClientDo - имитация клиентского вызова
func ClientDo(logger Logger) {
	logger.Log("HELLO FROM CLIENT")
}

func main() {
	oldPrinter := &OldPrinter{}
	adapterPrinter := &AdapterPrinter{oldPrinter}

	ClientDo(adapterPrinter)
}

// 1) паттерн применяется применяется чаще всего в случае когда существует legacy-код с механизмом который новым требованиям клиента не соответствует, но дорого или невыгодно менять/переписывать
// плюсами являются поддержание совместимости и гибкости системы и возможность использовать legacy и новый код без кардинальных изменений
// 2) из минусов можно выделить усложнение архитектуры сервиса, повышение количества абстракционных слоев в взаимодействиях компонентов системы, из чего может также пострадать произоводительность
// 3) пример использования может послужить интерфейс хранения юзеров напрямую через структуры и старое хранилище, которое использует JSON, как формат хранения, в этой ситуации мы пишем адаптер, который
// 4) будет хранить в себе экзмепляр старого хранилища и использовать его методы для сохранения/выдачи информации посредством маршалинга/анмаршалинга данных из/в JSON
// в этой ситуации мы не переписываем логику старого хранилища и в то же время удовлетворяем клиентскому интерфейсу взаимодействия с информацией о юзерах
